package me.herrlestrate.yandexintro.Parser;

import org.json.JSONException;
import org.json.JSONObject;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.FileNotFoundException;
import java.net.URL;
import java.util.Scanner;

import static org.junit.Assert.*;

public class CustomParserTest {

    private static Logger LOGGER = LoggerFactory.getLogger(CustomParserTest.class);

    @Before
    public void setUp() throws Exception {
    }

    @After
    public void tearDown() throws Exception {
    }

    /**
     * Эти тесты ловят ошибку при проверке на валидность строки
     * Поэтому, файл не создаётся. В логгере пишется какая именно причина.
     */
    @Test
    public void parseTo_FileNotFound() {
        File[] files = getResourceFolderFiles("FileNotFound");
        CustomParser customParser;
        for(int i = 0; i < files.length; i++){
            customParser = new CustomParser(files[i].getAbsolutePath());
            File file = new File("test-output.json");
            if(file.exists() && !file.delete()){
                LOGGER.error("Cannot delete test-output.json!");
            }
            customParser.parseTo("test-output.json");

            if(file.exists()){
                fail("[FileNotFound] File exists, but it is error! Test " + (i+1));
                if(!file.delete()){
                    LOGGER.error("Error while delete file!");
                }
            } else {
                assertTrue(true);
            }
        }
    }

    //

    /**
     * Эти тесты ловят успешный парсинг
     * Json'ы сравниваются по внутреннему содержимому, а не по строчкам
     */
    @Test
    public void parseTo_Success() {
        File[] files = getResourceFolderFiles("Success_Input");
        File[] output = getResourceFolderFiles("Success_Output");
        CustomParser customParser;
        for(int i = 0;i < files.length; i++){
            if(!output[i].exists()){
                LOGGER.error("For test " + (i+1) + " answer-output not founded!");
                continue;
            }
            customParser = new CustomParser(files[i].getAbsolutePath());
            File jOutput = new File("test-output.json");
            try {
                if (jOutput.exists() && !jOutput.delete()) {
                    LOGGER.error("Some errors with test-output.json");
                    fail("Cannot delete test-output.json");
                }
            }catch(SecurityException ex){
                ex.printStackTrace();
            }
            customParser.parseTo("test-output.json");
            boolean result = compare(output[i], jOutput);

            if (jOutput.exists() && !jOutput.delete()) {
            }

            assertTrue("Exception at test: " + (i+1), result);

        }
    }

    private boolean compare(File answer, File result){
        Scanner scanner;
        StringBuilder sbAnswer = new StringBuilder();
        StringBuilder sbResult = new StringBuilder();

        try {
            scanner = new Scanner(answer);
        } catch (FileNotFoundException e) {
            LOGGER.error("Answer file not Found!", e);
            return false;
        }

        while(scanner.hasNextLine()){
            String s = scanner.nextLine()
                    .toLowerCase();
            sbAnswer.append(s);
        }

        try {
            scanner = new Scanner(result);
        } catch (FileNotFoundException e) {
            LOGGER.error("Result file not Found!", e);
            return false;
        }

        while(scanner.hasNextLine()){
            String s = scanner.nextLine()
                    .toLowerCase();
            sbResult.append(s);
        }

        scanner.close();

        LOGGER.debug("Answer string: " + sbAnswer.toString());
        LOGGER.debug("Result string: " + sbResult.toString());

        try {
            JSONObject a = new JSONObject(sbAnswer.toString());
            JSONObject b = new JSONObject(sbResult.toString());
            return isJSONObjectEquals(a, b);
        } catch(JSONException exception){
            LOGGER.error("Exception at parse JSONObject ", exception);
            return false;
        }
    }

    /**
     * @param answer from source output file
     * @param result generated by parseTo method
     * @return is equals answer and result
     */
    private boolean isJSONObjectEquals(JSONObject answer, JSONObject result){
        return result.similar(answer);
    }

    //

    private File[] getResourceFolderFiles(String folder){
        URL url = getClass().getClassLoader().getResource(folder);
        String path = url.getPath();
        return new File(path).listFiles();
    }
}